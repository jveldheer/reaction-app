<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Audible Reaction Tools</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap');
  
  :root { 
    --primary-black: #1A1A1A;
    --primary-dark: #2C3E3A;
    --primary-yellow: #F5C842;
    --accent-yellow: #FFD700;
    --text-light: #FFFFFF;
    --text-gray: #B0B0B0;
    --card-bg: #2A2A2A;
    --card-border: #3A3A3A;
    --success: #4CAF50;
    --warning: #FF5722;
    --rest-color: #4A90E2;
    --shadow: rgba(0,0,0,0.5);
    --glow-yellow: rgba(245, 200, 66, 0.5);
  }
  
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  body {
    font-family: 'Bebas Neue', sans-serif;
    background: var(--primary-black);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    position: relative;
    overflow-x: hidden;
  }
  
  body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: 
      radial-gradient(circle at 20% 50%, rgba(245, 200, 66, 0.05) 0%, transparent 50%),
      radial-gradient(circle at 80% 50%, rgba(245, 200, 66, 0.05) 0%, transparent 50%);
    pointer-events: none;
    z-index: 1;
  }
  
  /* Brand Header */
  .brand-header {
    text-align: center;
    margin-bottom: 30px;
    animation: fadeInDown 0.8s ease;
    position: relative;
    z-index: 2;
  }
  
  .logo-container {
    background: linear-gradient(135deg, var(--card-bg) 0%, #1f1f1f 100%);
    padding: 20px 40px;
    border-radius: 15px;
    border: 2px solid var(--primary-yellow);
    box-shadow: 
      0 10px 30px var(--shadow),
      inset 0 1px 0 rgba(255,255,255,0.1),
      0 0 30px var(--glow-yellow);
    margin-bottom: 20px;
    position: relative;
    overflow: hidden;
  }
  
  img.logo {
    max-width: 250px;
    height: auto;
    margin-bottom: 10px;
    filter: drop-shadow(0 0 20px rgba(245, 200, 66, 0.3));
  }
  
  .app-title {
    color: var(--primary-yellow);
    font-size: 2.5em;
    letter-spacing: 3px;
    margin: 10px 0 0 0;
    text-shadow: 0 0 20px var(--glow-yellow);
    text-transform: uppercase;
  }
  
  /* Sections */
  section {
    display: none;
    width: 100%;
    max-width: 700px;
    animation: fadeIn 0.5s ease;
    position: relative;
    z-index: 2;
  }
  
  section.show {
    display: block;
  }
  
  /* Timer Cards */
  .timer-card {
    background: linear-gradient(135deg, var(--card-bg) 0%, #222 100%);
    border: 1px solid var(--card-border);
    border-radius: 20px;
    padding: 35px;
    box-shadow: 
      0 15px 40px rgba(0,0,0,0.5),
      inset 0 1px 0 rgba(255,255,255,0.05);
    margin-bottom: 20px;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    position: relative;
  }
  
  .timer-card::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 2px;
    background: linear-gradient(90deg, transparent, var(--primary-yellow), transparent);
    border-radius: 20px 20px 0 0;
  }
  
  .timer-card:hover {
    transform: translateY(-3px);
    box-shadow: 
      0 20px 50px rgba(0,0,0,0.6),
      0 0 20px rgba(245, 200, 66, 0.1);
  }
  
  /* Buttons */
  button {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.4em;
    padding: 15px 40px;
    margin: 10px;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
    letter-spacing: 2px;
    position: relative;
    overflow: hidden;
    text-transform: uppercase;
  }
  
  button::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    border-radius: 50%;
    background: rgba(255,255,255,0.3);
    transform: translate(-50%, -50%);
    transition: width 0.6s, height 0.6s;
  }
  
  button:active::before {
    width: 300px;
    height: 300px;
  }
  
  .primary-btn {
    background: linear-gradient(135deg, var(--primary-yellow) 0%, var(--accent-yellow) 100%);
    color: var(--primary-black);
    box-shadow: 
      0 5px 15px rgba(245,200,66,0.3),
      inset 0 1px 0 rgba(255,255,255,0.3);
    font-weight: bold;
  }
  
  .primary-btn:hover:not(:disabled) {
    background: linear-gradient(135deg, var(--accent-yellow) 0%, var(--primary-yellow) 100%);
    transform: translateY(-2px);
    box-shadow: 
      0 8px 25px rgba(245,200,66,0.4),
      0 0 20px var(--glow-yellow);
  }
  
  .primary-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }
  
  .secondary-btn {
    background: transparent;
    color: var(--text-light);
    border: 2px solid var(--primary-yellow);
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
  }
  
  .secondary-btn:hover {
    background: var(--primary-yellow);
    color: var(--primary-black);
    transform: translateY(-2px);
    box-shadow: 
      0 8px 20px rgba(245,200,66,0.3),
      0 0 15px var(--glow-yellow);
  }
  
  .mode-btn {
    width: 100%;
    max-width: 400px;
    margin: 15px auto;
    display: block;
    background: linear-gradient(135deg, #3A3A3A 0%, #2A2A2A 100%);
    color: var(--text-light);
    border: 1px solid var(--primary-yellow);
    position: relative;
  }
  
  .mode-btn:hover:not(:disabled) {
    background: linear-gradient(135deg, var(--primary-yellow) 0%, var(--accent-yellow) 100%);
    color: var(--primary-black);
    transform: translateY(-2px);
    box-shadow: 0 0 25px var(--glow-yellow);
  }
  
  .mode-btn .icon {
    display: inline-block;
    margin-right: 10px;
    font-size: 1.2em;
  }
  
  /* Input Change Listeners - Allow restart when values change */
[durEl, workTimeEl, restTimeEl, repsEl].forEach(input => {
  input.addEventListener('input', () => {
    if (drillActive && !drillPaused) {
      if (confirm('Changing settings will restart the drill. Continue?')) {
        stopDrill();
        startBtn.disabled = false;
      } else {
        // Revert to previous value
        if (input === durEl) input.value = input.dataset.prevValue || '30';
        if (input === workTimeEl) input.value = input.dataset.prevValue || '20';
        if (input === restTimeEl) input.value = input.dataset.prevValue || '10';
        if (input === repsEl) input.value = input.dataset.prevValue || '5';
      }
    }
  });
  
  input.addEventListener('focus', () => {
    input.dataset.prevValue = input.value;
  });
});
  .mode-toggle {
    display: flex;
    justify-content: center;
    margin: 25px 0;
    gap: 10px;
  }
  
  .toggle-btn {
    padding: 10px 25px;
    font-size: 1.1em;
    background: var(--card-bg);
    color: var(--text-gray);
    border: 1px solid var(--card-border);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    letter-spacing: 1px;
  }
  
  .toggle-btn.active {
    background: var(--primary-yellow);
    color: var(--primary-black);
    border-color: var(--primary-yellow);
    box-shadow: 0 0 15px var(--glow-yellow);
    font-weight: bold;
  }
  
  /* Input Groups */
  .input-group {
    margin: 20px 0;
    padding: 20px;
    background: rgba(0,0,0,0.3);
    border-radius: 10px;
    border: 1px solid var(--card-border);
  }
  
  .input-row {
    display: flex;
    justify-content: space-around;
    flex-wrap: wrap;
    gap: 20px;
    margin: 15px 0;
  }
  
  .input-field {
    flex: 1;
    min-width: 150px;
    text-align: center;
  }
  
  /* Input Fields */
  input[type="number"] {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.6em;
    padding: 12px;
    border: 2px solid var(--primary-yellow);
    border-radius: 10px;
    width: 100%;
    max-width: 150px;
    text-align: center;
    background: var(--primary-black);
    color: var(--text-light);
    transition: all 0.3s ease;
    letter-spacing: 2px;
  }
  
  input[type="number"]:focus {
    outline: none;
    box-shadow: 0 0 20px var(--glow-yellow);
    background: #1f1f1f;
  }
  
  input[type="number"]:disabled {
    opacity: 0.4;
    background: #151515;
    border-color: #444;
  }
  
  /* Labels */
  label {
    font-size: 1.1em;
    color: var(--primary-yellow);
    letter-spacing: 1px;
    margin-bottom: 8px;
    display: block;
    text-transform: uppercase;
    text-shadow: 0 0 10px rgba(245, 200, 66, 0.3);
  }
  
  /* Countdown Display */
  #countdown {
    font-size: 5em;
    margin: 30px 0;
    color: var(--primary-yellow);
    text-shadow: 
      3px 3px 6px rgba(0,0,0,0.8),
      0 0 30px var(--glow-yellow);
    min-height: 120px;
    display: flex;
    align-items: center;
    justify-content: center;
    letter-spacing: 3px;
    animation: none;
  }
  
  #countdown.active {
    animation: pulse 1s ease-in-out infinite;
  }
  
  #countdown.go {
    color: var(--success);
    animation: bounce 0.5s ease;
    text-shadow: 0 0 40px rgba(76, 175, 80, 0.8);
  }
  
  #countdown.rest {
    color: var(--rest-color);
    text-shadow: 0 0 30px rgba(74, 144, 226, 0.8);
  }
  
  /* Status Display */
  .status-display {
    background: rgba(0,0,0,0.5);
    border: 1px solid var(--primary-yellow);
    border-radius: 10px;
    padding: 15px;
    margin: 20px 0;
    display: none;
  }
  
  .status-display.show {
    display: block;
  }
  
  .status-row {
    display: flex;
    justify-content: space-around;
    color: var(--text-light);
    font-size: 1.2em;
    letter-spacing: 1px;
  }
  
  .status-item {
    text-align: center;
  }
  
  .status-label {
    color: var(--text-gray);
    font-size: 0.9em;
    margin-bottom: 5px;
  }
  
  .status-value {
    color: var(--primary-yellow);
    font-size: 1.5em;
    font-weight: bold;
    text-shadow: 0 0 10px var(--glow-yellow);
  }
  
  /* Info Box */
  .info-box {
    background: linear-gradient(135deg, rgba(245, 200, 66, 0.1) 0%, rgba(255, 215, 0, 0.05) 100%);
    color: var(--text-light);
    padding: 15px 20px;
    border-radius: 10px;
    margin: 20px 0;
    border: 1px solid rgba(245, 200, 66, 0.3);
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    font-size: 1.1em;
    letter-spacing: 0.5px;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  
  .info-box .icon {
    font-size: 1.5em;
    color: var(--primary-yellow);
  }
  
  /* Loading Spinner */
  .loading-container {
    margin: 30px 0;
    text-align: center;
  }
  
  .spinner {
    display: inline-block;
    width: 50px;
    height: 50px;
    border: 4px solid rgba(245, 200, 66, 0.1);
    border-top-color: var(--primary-yellow);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }
  
  .loading-text {
    color: var(--text-gray);
    font-size: 1.2em;
    margin-top: 15px;
    letter-spacing: 1px;
    text-transform: uppercase;
  }
  
  /* Ringer Bar */
  #ringerBar {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    background: linear-gradient(90deg, var(--warning) 0%, #ff7043 100%);
    color: white;
    font-size: 1.1em;
    padding: 12px;
    text-align: center;
    z-index: 1000;
    box-shadow: 0 -5px 20px rgba(0,0,0,0.5);
    letter-spacing: 1px;
    animation: slideUp 0.5s ease;
  }
  
  /* Drill Active Indicator */
  .drill-active {
    position: fixed;
    top: 20px;
    right: 20px;
    background: linear-gradient(135deg, var(--success) 0%, #66BB6A 100%);
    color: white;
    padding: 10px 20px;
    border-radius: 30px;
    display: none;
    align-items: center;
    gap: 10px;
    box-shadow: 0 5px 15px rgba(76,175,80,0.4);
    animation: slideIn 0.3s ease;
    z-index: 10;
  }
  
  .drill-active.show {
    display: flex;
  }
  
  .drill-active.rest {
    background: linear-gradient(135deg, var(--rest-color) 0%, #5BA0F2 100%);
    box-shadow: 0 5px 15px rgba(74,144,226,0.4);
  }
  
  .pulse-dot {
    width: 10px;
    height: 10px;
    background: white;
    border-radius: 50%;
    animation: pulseDot 1s ease-in-out infinite;
  }
  
  /* Animations */
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
  }
  
  @keyframes fadeInDown {
    from { opacity: 0; transform: translateY(-30px); }
    to { opacity: 1; transform: translateY(0); }
  }
  
  @keyframes pulse {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.05); opacity: 0.8; }
  }
  
  @keyframes bounce {
    0%, 100% { transform: translateY(0); }
    25% { transform: translateY(-20px); }
    50% { transform: translateY(0); }
    75% { transform: translateY(-10px); }
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  
  @keyframes slideUp {
    from { transform: translateY(100%); }
    to { transform: translateY(0); }
  }
  
  @keyframes slideIn {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
  
  @keyframes pulseDot {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }
  
  /* Responsive Design */
  @media (max-width: 600px) {
    img.logo { max-width: 200px; }
    .app-title { font-size: 2em; }
    button { font-size: 1.2em; padding: 12px 30px; }
    #countdown { font-size: 3.5em; }
    input[type="number"] { max-width: 120px; font-size: 1.4em; }
    .input-row { gap: 15px; }
    .mode-toggle { flex-direction: column; }
    .toggle-btn { width: 100%; }
  }
</style>
</head>
<body>

<!-- Brand Header -->
<div class="brand-header">
  <div class="logo-container">
    <img src="vlvl16x9.png" class="logo" alt="VLVL Logo">
    <h1 class="app-title">Audible Reaction Tools</h1>
  </div>
</div>

<!-- Landing Section -->
<section id="landing" class="show">
  <div class="timer-card">
    <h2 style="text-align: center; color: var(--primary-yellow); font-size: 2.2em; margin-bottom: 30px; letter-spacing: 3px; text-shadow: 0 0 15px var(--glow-yellow);">
      SELECT TRAINING MODE
    </h2>
    
    <div class="loading-container" id="loadingContainer">
      <div class="spinner"></div>
      <div class="loading-text">Initializing Audio System...</div>
    </div>
    
    <div id="timerButtons" style="display: none;">
      <button class="mode-btn" data-mode="clap" disabled>
        <span class="icon">👏</span> AUDIBLE CLAP TIMER
      </button>
      <button class="mode-btn" data-mode="number" disabled>
        <span class="icon">🔢</span> AUDIBLE NUMBER TIMER
      </button>
      <button class="mode-btn" data-mode="direction" disabled>
        <span class="icon">🧭</span> AUDIBLE DIRECTION TIMER
      </button>
    </div>
  </div>
</section>

<!-- Timer Section -->
<section id="timer">
  <div class="timer-card">
    <h1 id="title" style="text-align: center; color: var(--primary-yellow); font-size: 2em; margin-bottom: 25px; letter-spacing: 3px; text-shadow: 0 0 15px var(--glow-yellow);"></h1>
    
    <!-- Training Mode Toggle -->
    <div class="mode-toggle">
      <button class="toggle-btn active" id="basicMode">BASIC MODE</button>
      <button class="toggle-btn" id="intervalMode">INTERVAL MODE</button>
    </div>
    
    <!-- Basic Mode Settings -->
    <div id="basicSettings" class="input-group">
      <div class="input-field">
        <label for="duration">Training Duration (Seconds)</label>
        <input id="duration" type="number" min="5" max="300" value="30" step="5">
      </div>
    </div>
    
    <!-- Interval Mode Settings -->
    <div id="intervalSettings" class="input-group" style="display: none;">
      <div class="input-row">
        <div class="input-field">
          <label for="workTime">Work Time (Sec)</label>
          <input id="workTime" type="number" min="5" max="120" value="20" step="5">
        </div>
        <div class="input-field">
          <label for="restTime">Rest Time (Sec)</label>
          <input id="restTime" type="number" min="5" max="60" value="10" step="5">
        </div>
        <div class="input-field">
          <label for="reps">Reps</label>
          <input id="reps" type="number" min="1" max="20" value="5" step="1">
        </div>
      </div>
    </div>
    
    <!-- Status Display -->
    <div id="statusDisplay" class="status-display">
      <div class="status-row">
        <div class="status-item">
          <div class="status-label">CURRENT REP</div>
          <div class="status-value" id="currentRep">0/0</div>
        </div>
        <div class="status-item">
          <div class="status-label">PHASE</div>
          <div class="status-value" id="currentPhase">-</div>
        </div>
        <div class="status-item">
          <div class="status-label">TIME LEFT</div>
          <div class="status-value" id="timeLeft">0s</div>
        </div>
      </div>
    </div>
    
    <div id="countdown"></div>
    
    <div style="text-align: center;">
      <button id="startBtn" class="primary-btn">START DRILL</button>
      <button id="pauseBtn" class="primary-btn" style="display: none;">PAUSE</button>
      <button id="stopBtn" class="secondary-btn" style="display: none;">STOP</button>
      <button id="backBtn" class="secondary-btn">← BACK TO MENU</button>
    </div>
  </div>
  
  <div class="info-box">
    <span class="icon">⚡</span>
    <span id="infoText">React quickly to audio cues! Randomized intervals keep you sharp.</span>
  </div>
</section>

<!-- Drill Active Indicator -->
<div class="drill-active" id="drillIndicator">
  <div class="pulse-dot"></div>
  <span id="drillStatus">DRILL ACTIVE</span>
</div>

<!-- Ringer Reminder -->
<div id="ringerBar">
  🔊 IMPORTANT: Enable your device's sound/ringer for audio cues
</div>

<script>
/* Enhanced VLV Reaction Timer with Intervals */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const synth = window.speechSynthesis;
let voiceEN = null;
let drillActive = false;
let drillPaused = false;
let drillTimeouts = [];
let intervalTimer = null;
let trainingMode = 'basic';
let pausedTimeLeft = 0;
let pausedPhase = '';
let pausedEndTime = 0;

// DOM Elements
const landing = document.getElementById('landing');
const timerPg = document.getElementById('timer');
const loadingContainer = document.getElementById('loadingContainer');
const timerButtons = document.getElementById('timerButtons');
const startBtns = document.querySelectorAll('button[data-mode]');
const titleEl = document.getElementById('title');
const durEl = document.getElementById('duration');
const workTimeEl = document.getElementById('workTime');
const restTimeEl = document.getElementById('restTime');
const repsEl = document.getElementById('reps');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const stopBtn = document.getElementById('stopBtn');
const backBtn = document.getElementById('backBtn');
const countEl = document.getElementById('countdown');
const drillIndicator = document.getElementById('drillIndicator');
const drillStatus = document.getElementById('drillStatus');
const ringerBar = document.getElementById('ringerBar');
const infoText = document.getElementById('infoText');

// Mode Toggle Elements
const basicModeBtn = document.getElementById('basicMode');
const intervalModeBtn = document.getElementById('intervalMode');
const basicSettings = document.getElementById('basicSettings');
const intervalSettings = document.getElementById('intervalSettings');
const statusDisplay = document.getElementById('statusDisplay');

// Status Elements
const currentRepEl = document.getElementById('currentRep');
const currentPhaseEl = document.getElementById('currentPhase');
const timeLeftEl = document.getElementById('timeLeft');

let mode = '';
let lastVal = null;
let currentRep = 0;
let totalReps = 0;
let isResting = false;

/* Training Mode Toggle */
basicModeBtn.onclick = () => {
  trainingMode = 'basic';
  basicModeBtn.classList.add('active');
  intervalModeBtn.classList.remove('active');
  basicSettings.style.display = 'block';
  intervalSettings.style.display = 'none';
  statusDisplay.classList.remove('show');
  infoText.textContent = 'React quickly to audio cues! Randomized intervals keep you sharp.';
};

intervalModeBtn.onclick = () => {
  trainingMode = 'interval';
  intervalModeBtn.classList.add('active');
  basicModeBtn.classList.remove('active');
  intervalSettings.style.display = 'block';
  basicSettings.style.display = 'none';
  infoText.textContent = 'Interval training: Work hard, rest, repeat! Build endurance and reaction speed.';
};

/* Enhanced Audio Functions */
const tone = (freq = 1000, duration = 200, type = 'sine') => {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  
  osc.type = type;
  osc.frequency.value = freq;
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  
  gain.gain.setValueAtTime(0, audioCtx.currentTime);
  gain.gain.linearRampToValueAtTime(1, audioCtx.currentTime + 0.01);
  gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + duration/1000);
  
  osc.start();
  osc.stop(audioCtx.currentTime + duration/1000);
};

const clap = () => {
  const duration = 0.15;
  const sampleRate = audioCtx.sampleRate;
  const length = sampleRate * duration;
  const buffer = audioCtx.createBuffer(1, length, sampleRate);
  const data = buffer.getChannelData(0);
  
  for (let i = 0; i < length; i++) {
    const envelope = Math.pow(1 - i/length, 2);
    const noise = (Math.random() * 2 - 1);
    data[i] = noise * envelope * 0.8;
  }
  
  const source = audioCtx.createBufferSource();
  const filter = audioCtx.createBiquadFilter();
  
  source.buffer = buffer;
  filter.type = 'highpass';
  filter.frequency.value = 1000;
  
  source.connect(filter);
  filter.connect(audioCtx.destination);
  source.start();
};

const doubleBeep = () => {
  tone(600, 150, 'sine');
  setTimeout(() => tone(800, 150, 'sine'), 200);
};

const tripleBeep = () => {
  tone(500, 100);
  setTimeout(() => tone(600, 100), 150);
  setTimeout(() => tone(700, 100), 300);
};

/* Speech Function */
function speak(text, rate = 1) {
  return new Promise((resolve) => {
    if (!synth) {
      console.warn('Speech synthesis not available');
      resolve();
      return;
    }
    
    const utterance = new SpeechSynthesisUtterance(text);
    if (voiceEN) {
      utterance.voice = voiceEN;
    }
    utterance.lang = 'en-US';
    utterance.volume = 1;
    utterance.rate = rate;
    utterance.pitch = 1;
    utterance.onend = () => resolve();
    utterance.onerror = () => {
      console.error('Speech error');
      resolve();
    };
    
    synth.cancel();
    synth.speak(utterance);
  });
}

/* Voice Loading */
function loadVoices() {
  return new Promise((resolve) => {
    if (!synth) {
      console.warn('Speech synthesis not supported');
      resolve();
      return;
    }
    
    const checkVoices = () => {
      const voices = synth.getVoices();
      voiceEN = voices.find(v => v.lang === 'en-US') ||
                voices.find(v => v.lang.startsWith('en')) ||
                voices[0];
      
      if (voiceEN) {
        console.log('Voice loaded:', voiceEN.name);
        resolve();
      }
    };
    
    checkVoices();
    
    if (!voiceEN && synth.onvoiceschanged !== undefined) {
      synth.onvoiceschanged = () => {
        checkVoices();
        if (voiceEN) resolve();
      };
      
      setTimeout(() => {
        console.warn('Voice loading timeout, proceeding anyway');
        resolve();
      }, 3000);
    }
  });
}

/* Initialize */
loadVoices().then(() => {
  loadingContainer.style.display = 'none';
  timerButtons.style.display = 'block';
  startBtns.forEach(btn => btn.disabled = false);
  
  setTimeout(() => {
    if (ringerBar) {
      ringerBar.style.animation = 'slideUp 0.5s ease reverse';
      setTimeout(() => {
        if (ringerBar) ringerBar.style.display = 'none';
      }, 500);
    }
  }, 10000);
});

/* Mode Selection */
startBtns.forEach(btn => {
  btn.onclick = () => {
    mode = btn.dataset.mode;
    
    const titles = {
      clap: 'CLAP REACTION DRILL',
      number: 'NUMBER REACTION DRILL',
      direction: 'DIRECTION REACTION DRILL'
    };
    
    titleEl.textContent = titles[mode];
    durEl.value = '30';
    workTimeEl.value = '20';
    restTimeEl.value = '10';
    repsEl.value = '5';
    lastVal = null;
    countEl.textContent = '';
    countEl.className = '';
    currentRep = 0;
    totalReps = 0;
    isResting = false;
    
    landing.classList.remove('show');
    timerPg.classList.add('show');
  };
});

/* Back Button */
backBtn.onclick = () => {
  if (drillActive) {
    if (!confirm('Stop the current drill and return to menu?')) return;
    stopDrill();
  }
  
  timerPg.classList.remove('show');
  landing.classList.add('show');
  drillIndicator.classList.remove('show');
  statusDisplay.classList.remove('show');
};

/* Stop Button */
stopBtn.onclick = () => {
  if (confirm('Stop the current drill?')) {
    stopDrill();
  }
};

/* Pause/Resume Button */
pauseBtn.onclick = () => {
  if (drillPaused) {
    resumeDrill();
  } else {
    pauseDrill();
  }
};

/* Pause Drill Function */
function pauseDrill() {
  if (!drillActive || drillPaused) return;
  
  drillPaused = true;
  pauseBtn.textContent = 'RESUME';
  pauseBtn.style.background = 'linear-gradient(135deg, var(--success) 0%, #66BB6A 100%)';
  
  // Store current state
  if (intervalTimer) {
    clearInterval(intervalTimer);
    const now = Date.now();
    pausedTimeLeft = Math.max(0, pausedEndTime - now);
  }
  
  // Clear all active timeouts
  drillTimeouts.forEach(timeout => clearTimeout(timeout));
  drillTimeouts = [];
  
  // Update visual indicators
  drillStatus.textContent = 'PAUSED';
  countEl.textContent = 'PAUSED';
  countEl.className = '';
  
  // Pause speech
  if (synth.speaking) {
    synth.pause();
  }
}

/* Resume Drill Function */
function resumeDrill() {
  if (!drillActive || !drillPaused) return;
  
  drillPaused = false;
  pauseBtn.textContent = 'PAUSE';
  pauseBtn.style.background = '';
  
  // Resume speech
  if (synth.paused) {
    synth.resume();
  }
  
  // Resume countdown
  countEl.textContent = isResting ? 'REST' : 'WORK!';
  countEl.className = isResting ? 'rest' : 'go';
  drillStatus.textContent = isResting ? 'REST PHASE' : 'WORK PHASE';
  
  // Resume the interval training with remaining time
  if (trainingMode === 'interval' && pausedTimeLeft > 0) {
    continueIntervalPhase(pausedTimeLeft);
  } else if (trainingMode === 'basic' && pausedTimeLeft > 0) {
    const endTime = Date.now() + pausedTimeLeft;
    randomLoop(endTime);
    const finishTimeout = setTimeout(() => {
      finishDrill();
    }, pausedTimeLeft);
    drillTimeouts.push(finishTimeout);
  }
}

/* Stop Drill Function */
function stopDrill() {
  drillActive = false;
  drillPaused = false;
  isResting = false;
  pausedTimeLeft = 0;
  
  // Clear all timeouts
  drillTimeouts.forEach(timeout => clearTimeout(timeout));
  drillTimeouts = [];
  
  if (intervalTimer) {
    clearInterval(intervalTimer);
    intervalTimer = null;
  }
  
  // Cancel any speaking
  if (synth.speaking) {
    synth.cancel();
  }
  
  durEl.disabled = false;
  workTimeEl.disabled = false;
  restTimeEl.disabled = false;
  repsEl.disabled = false;
  startBtn.disabled = false;
  startBtn.style.display = 'inline-block';
  pauseBtn.style.display = 'none';
  stopBtn.style.display = 'none';
  backBtn.disabled = false;
  basicModeBtn.disabled = false;
  intervalModeBtn.disabled = false;
  
  drillIndicator.classList.remove('show');
  drillIndicator.classList.remove('rest');
  statusDisplay.classList.remove('show');
  countEl.textContent = '';
  countEl.className = '';
}

/* Trigger Function */
const trigger = async () => {
  if (!drillActive || isResting) return;
  
  if (mode === 'clap') {
    clap();
  } else if (mode === 'number') {
    let num;
    do {
      num = Math.floor(Math.random() * 5) + 1;
    } while (num === lastVal);
    lastVal = num;
    await speak(String(num), 1.3);
  } else if (mode === 'direction') {
    const directions = ['right', 'left', 'back', 'forward'];
    let dir;
    do {
      dir = directions[Math.floor(Math.random() * directions.length)];
    } while (dir === lastVal);
    lastVal = dir;
    await speak(dir, 1.3);
  }
};

/* Random Loop */
const randomLoop = (endTime) => {
  if (!drillActive || drillPaused || isResting || Date.now() >= endTime - 400) return;
  
  const delay = Math.random() * 1500 + 500; // 0.5-2 seconds
  const timeout = setTimeout(async () => {
    if (drillActive && !drillPaused && !isResting && Date.now() < endTime - 200) {
      await trigger();
      randomLoop(endTime);
    }
  }, delay);
  
  drillTimeouts.push(timeout);
};

/* Basic Training */
const startBasicTraining = async () => {
  const totalMs = parseInt(durEl.value) * 1000;
  pausedEndTime = Date.now() + totalMs;
  
  await trigger();
  const endTime = Date.now() + totalMs;
  randomLoop(endTime);
  
  const finishTimeout = setTimeout(() => {
    finishDrill();
  }, totalMs);
  
  drillTimeouts.push(finishTimeout);
};

/* Continue Interval Phase After Pause */
const continueIntervalPhase = async (remainingTime) => {
  pausedEndTime = Date.now() + remainingTime;
  
  // Update timer display
  if (intervalTimer) clearInterval(intervalTimer);
  intervalTimer = setInterval(() => {
    if (!drillActive || drillPaused) return;
    const timeLeft = Math.max(0, pausedEndTime - Date.now());
    timeLeftEl.textContent = Math.ceil(timeLeft / 1000) + 's';
    
    if (timeLeft <= 0) {
      clearInterval(intervalTimer);
    }
  }, 100);
  
  // Continue triggers if in work phase
  if (!isResting) {
    randomLoop(pausedEndTime);
  }
  
  // Wait for phase to end
  await new Promise(resolve => {
    const timeout = setTimeout(() => {
      if (drillActive && !drillPaused) {
        resolve();
      }
    }, remainingTime);
    drillTimeouts.push(timeout);
  });
  
  if (!drillActive || drillPaused) return;
  
  // Move to next phase
  if (!isResting && currentRep < totalReps) {
    // Start rest phase
    isResting = true;
    currentPhaseEl.textContent = 'REST';
    currentPhaseEl.style.color = 'var(--rest-color)';
    drillIndicator.classList.add('rest');
    drillStatus.textContent = 'REST PHASE';
    countEl.textContent = 'REST';
    countEl.className = 'rest';
    
    doubleBeep();
    
    try {
      await speak('rest', 1.2);
    } catch (e) {
      console.log('Speech error:', e);
    }
    
    const restTime = parseInt(restTimeEl.value) * 1000;
    pausedEndTime = Date.now() + restTime;
    
    if (intervalTimer) clearInterval(intervalTimer);
    intervalTimer = setInterval(() => {
      if (!drillActive || drillPaused) return;
      const timeLeft = Math.max(0, pausedEndTime - Date.now());
      timeLeftEl.textContent = Math.ceil(timeLeft / 1000) + 's';
      
      if (timeLeft <= 3000 && timeLeft > 2900) {
        tone(600, 100);
      }
      
      if (timeLeft <= 0) {
        clearInterval(intervalTimer);
      }
    }, 100);
    
    await new Promise(resolve => {
      const timeout = setTimeout(() => {
        if (drillActive && !drillPaused) {
          resolve();
        }
      }, restTime);
      drillTimeouts.push(timeout);
    });
    
    if (!drillActive || drillPaused) return;
    
    currentRep++;
    setTimeout(() => {
      if (drillActive && !drillPaused) {
        runInterval();
      }
    }, 0);
  } else if (isResting) {
    // Move to next rep
    currentRep++;
    setTimeout(() => {
      if (drillActive && !drillPaused) {
        runInterval();
      }
    }, 0);
  } else {
    // Final rep completed
    finishDrill();
  }
};

/* Interval Training */
const runInterval = async () => {
  if (!drillActive || currentRep > totalReps) {
    finishDrill();
    return;
  }
  
  // Update status
  currentRepEl.textContent = `${currentRep}/${totalReps}`;
  
  // Work phase
  isResting = false;
  currentPhaseEl.textContent = 'WORK';
  currentPhaseEl.style.color = 'var(--primary-yellow)';
  drillIndicator.classList.remove('rest');
  drillStatus.textContent = 'WORK PHASE';
  countEl.textContent = 'WORK!';
  countEl.className = 'go';
  
  tone(1000, 300, 'square');
  
  try {
    await speak('work', 1.5);
  } catch (e) {
    console.log('Speech error:', e);
  }
  
  // Start work timer
  const workTime = parseInt(workTimeEl.value) * 1000;
  pausedEndTime = Date.now() + workTime;
  
  // Update timer display
  if (intervalTimer) clearInterval(intervalTimer);
  intervalTimer = setInterval(() => {
    if (!drillActive || drillPaused) return;
    const timeLeft = Math.max(0, pausedEndTime - Date.now());
    timeLeftEl.textContent = Math.ceil(timeLeft / 1000) + 's';
    
    if (timeLeft <= 0) {
      clearInterval(intervalTimer);
    }
  }, 100);
  
  // Run triggers during work phase
  trigger().catch(console.error);
  randomLoop(pausedEndTime);
  
  // Wait for work phase to end
  await new Promise(resolve => {
    const timeout = setTimeout(() => {
      if (drillActive && !drillPaused) {
        resolve();
      }
    }, workTime);
    drillTimeouts.push(timeout);
  });
  
  if (!drillActive || drillPaused) return;
  
  // Rest phase (skip on last rep)
  if (currentRep < totalReps) {
    isResting = true;
    currentPhaseEl.textContent = 'REST';
    currentPhaseEl.style.color = 'var(--rest-color)';
    drillIndicator.classList.add('rest');
    drillStatus.textContent = 'REST PHASE';
    countEl.textContent = 'REST';
    countEl.className = 'rest';
    
    doubleBeep();
    
    try {
      await speak('rest', 1.2);
    } catch (e) {
      console.log('Speech error:', e);
    }
    
    // Rest timer
    const restTime = parseInt(restTimeEl.value) * 1000;
    pausedEndTime = Date.now() + restTime;
    
    if (intervalTimer) clearInterval(intervalTimer);
    intervalTimer = setInterval(() => {
      if (!drillActive || drillPaused) return;
      const timeLeft = Math.max(0, pausedEndTime - Date.now());
      timeLeftEl.textContent = Math.ceil(timeLeft / 1000) + 's';
      
      if (timeLeft <= 3000 && timeLeft > 2900) {
        tone(600, 100);
      }
      
      if (timeLeft <= 0) {
        clearInterval(intervalTimer);
      }
    }, 100);
    
    await new Promise(resolve => {
      const timeout = setTimeout(() => {
        if (drillActive && !drillPaused) {
          resolve();
        }
      }, restTime);
      drillTimeouts.push(timeout);
    });
  }
  
  if (!drillActive || drillPaused) return;
  
  currentRep++;
  
  // Use setTimeout to avoid stack overflow
  setTimeout(() => {
    if (drillActive && !drillPaused) {
      runInterval();
    }
  }, 0);
};

const startIntervalTraining = () => {
  totalReps = parseInt(repsEl.value);
  currentRep = 1;
  
  statusDisplay.classList.add('show');
  
  // Start the interval loop
  setTimeout(() => runInterval(), 100);
};

/* Finish Drill */
const finishDrill = () => {
  stopDrill();
  tripleBeep();
  countEl.textContent = 'COMPLETE!';
  countEl.className = 'go';
  
  if (trainingMode === 'interval') {
    currentPhaseEl.textContent = 'DONE';
    currentPhaseEl.style.color = 'var(--success)';
    timeLeftEl.textContent = '0s';
  }
  
  const timeout = setTimeout(() => {
    countEl.textContent = '';
    countEl.className = '';
    statusDisplay.classList.remove('show');
  }, 3000);
  
  drillTimeouts.push(timeout);
};

/* Main Start Function */
startBtn.onclick = async () => {
  // Resume audio context
  await audioCtx.resume();
  
  // Validate inputs
  if (trainingMode === 'basic') {
    const duration = parseInt(durEl.value);
    if (isNaN(duration) || duration < 5 || duration > 300) {
      alert('Please enter a duration between 5 and 300 seconds');
      return;
    }
  } else {
    const workTime = parseInt(workTimeEl.value);
    const restTime = parseInt(restTimeEl.value);
    const reps = parseInt(repsEl.value);
    
    if (isNaN(workTime) || workTime < 5 || workTime > 120) {
      alert('Work time must be between 5 and 120 seconds');
      return;
    }
    if (isNaN(restTime) || restTime < 5 || restTime > 60) {
      alert('Rest time must be between 5 and 60 seconds');
      return;
    }
    if (isNaN(reps) || reps < 1 || reps > 20) {
      alert('Reps must be between 1 and 20');
      return;
    }
  }
  
  // Test speech
  await speak('ready', 1.2);
  
  // Disable controls
  durEl.disabled = true;
  workTimeEl.disabled = true;
  restTimeEl.disabled = true;
  repsEl.disabled = true;
  startBtn.style.display = 'none';
  pauseBtn.style.display = 'inline-block';
  pauseBtn.textContent = 'PAUSE';
  pauseBtn.style.background = '';
  stopBtn.style.display = 'inline-block';
  backBtn.disabled = true;
  basicModeBtn.disabled = true;
  intervalModeBtn.disabled = true;
  drillActive = true;
  drillPaused = false;
  
  // Countdown
  let countdownValue = 3;
  const countdown = () => {
    if (countdownValue > 0) {
      countEl.textContent = countdownValue;
      countEl.className = 'active';
      tone(800, 150);
      countdownValue--;
      const timeout = setTimeout(countdown, 1000);
      drillTimeouts.push(timeout);
    } else {
      countEl.textContent = 'GO!';
      countEl.className = 'go';
      drillIndicator.classList.add('show');
      
      // Start training based on mode
      if (trainingMode === 'basic') {
        startBasicTraining();
      } else {
        startIntervalTraining();
      }
    }
  };
  
  countdown();
};

/* Prevent accidental page leave */
window.addEventListener('beforeunload', (e) => {
  if (drillActive) {
    e.preventDefault();
    e.returnValue = '';
  }
});
</script>

</body>
</html>
